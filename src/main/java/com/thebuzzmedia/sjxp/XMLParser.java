/**   
 * Copyright 2011 The Buzz Media, LLC
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.thebuzzmedia.sjxp;

import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
import org.xmlpull.v1.XmlPullParserFactory;

import com.thebuzzmedia.sjxp.rule.IRule;

public class XMLParser {
	public static final Boolean DEBUG = Boolean.getBoolean("sjxp.debug");

	public static final Boolean ENABLE_NAMESPACES = (System
			.getProperty("sjxp.namespaces") == null ? Boolean.TRUE : Boolean
			.getBoolean("sjxp.namespaces"));
	public static final Boolean ENABLE_VALIDATION = Boolean
			.getBoolean("sjxp.validation");

	/**
	 * Prefix to every log message this library logs. Using a well-defined
	 * prefix helps make it easier both visually and programmatically to scan
	 * log files for messages produced by this library.
	 */
	public static final String LOG_MESSAGE_PREFIX = "[sjxp] ";

	public static final XmlPullParserFactory XPP_FACTORY;

	static {
		if (DEBUG)
			log("Debug output ENABLED");

		try {
			XPP_FACTORY = XmlPullParserFactory.newInstance();

			// Configure pull parser features
			XPP_FACTORY.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES,
					ENABLE_NAMESPACES);
			XPP_FACTORY.setFeature(XmlPullParser.FEATURE_VALIDATION,
					ENABLE_VALIDATION);

			if (DEBUG)
				log("XmlPullParserFactory configured [namespaces=%s, validation=%s]",
						ENABLE_NAMESPACES, ENABLE_VALIDATION);
		} catch (XmlPullParserException e) {
			throw new RuntimeException(
					"An exception occurred while calling XmlPullParserFactory.newInstance(). A library providing the impl of the XML Pull Parser spec (e.g. XPP3 or Android SDK) must be available at runtime.",
					e);
		}
	}

	private Location location;
	private XmlPullParser xpp;
	private Map<String, List<IRule>> attrRuleMap;
	private Map<String, List<IRule>> charRuleMap;

	public XMLParser(IRule... rules) throws IllegalArgumentException,
			XMLParserException {
		if (rules == null || rules.length == 0)
			throw new IllegalArgumentException(
					"rules cannot be null or empty, you must provide at least 1 rule to execute otherwise parsing will do nothing.");

		location = new Location();

		try {
			xpp = XPP_FACTORY.newPullParser();
		} catch (XmlPullParserException e) {
			throw new XMLParserException(
					"An exception occurred while trying to create a new XmlPullParser instance using the XmlPullParserFactory.",
					e);
		}

		// calculate a rough optimal size for the rule maps
		int optSize = (rules.length > 64 ? rules.length * 2 : 64);

		// init the rule maps
		attrRuleMap = new HashMap<String, List<IRule>>(optSize);
		charRuleMap = new HashMap<String, List<IRule>>(optSize);

		// init the rules
		List<IRule> ruleList = null;

		for (IRule rule : rules) {
			switch (rule.getType()) {
			case ATTRIBUTE:
				// Get the rule list for this path
				ruleList = attrRuleMap.get(rule.getLocationPath());

				// If there wasn't already a rule list, create and add it
				if (ruleList == null) {
					ruleList = new ArrayList<IRule>(3);
					attrRuleMap.put(rule.getLocationPath(), ruleList);
				}
				break;

			case CHARACTER:
				// Get the rule list for this path
				ruleList = charRuleMap.get(rule.getLocationPath());

				// If there wasn't already a rule list, create and add it
				if (ruleList == null) {
					ruleList = new ArrayList<IRule>(3);
					charRuleMap.put(rule.getLocationPath(), ruleList);
				}
				break;
			}

			// Add the rule to the list for the given path
			ruleList.add(rule);
		}

		if (DEBUG)
			log("Initialized %d ATTRIBUTE rules and %d CHARACTER rules.",
					attrRuleMap.size(), charRuleMap.size());
	}

	/**
	 * Helper method used to ensure a message is loggable before it is logged
	 * and then pre-pend a universal prefix to all log messages generated by
	 * this library to make the log entries easy to parse visually or
	 * programmatically.
	 * <p/>
	 * If a message cannot be logged (logging is disabled) then this method
	 * returns immediately.
	 * <p/>
	 * <strong>NOTE</strong>: Because Java will auto-box primitive arguments
	 * into Objects when building out the <code>params</code> array, care should
	 * be taken not to call this method with primitive values unless
	 * {@link #DEBUG} is <code>true</code>; otherwise the VM will be spending
	 * time performing unnecessary auto-boxing calculations.
	 * 
	 * @param message
	 *            The log message in <a href=
	 *            "http://download.oracle.com/javase/6/docs/api/java/util/Formatter.html#syntax"
	 *            >format string syntax</a> that will be logged.
	 * @param params
	 *            The parameters that will be swapped into all the place holders
	 *            in the original messages before being logged.
	 * 
	 * @see #LOG_MESSAGE_PREFIX
	 */
	protected static void log(String message, Object... params) {
		if (DEBUG)
			System.out.printf(LOG_MESSAGE_PREFIX + message + '\n', params);
	}

	public void parse(InputStream source) throws IllegalArgumentException,
			XMLParserException {
		try {
			parse(source, null);
		} catch (UnsupportedEncodingException e) {
			// no-op, this should never happen as null is a valid encoding.
		}
	}

	public void parse(InputStream source, String encoding)
			throws IllegalArgumentException, UnsupportedEncodingException,
			XMLParserException {
		if (source == null)
			throw new IllegalArgumentException("source cannot be null");
		if (encoding != null) {
			// If empty, ensure it is null so XPP gets encoding from XML header
			if (encoding.trim().length() == 0)
				encoding = null;
			// Extra-safe, make sure the provided encoding is valid
			else if (!Charset.isSupported(encoding))
				throw new UnsupportedEncodingException(
						"Encoding ["
								+ encoding
								+ "] is not a valid charset encoding in this runtime according to Charset.isSupported(encoding).");
		}

		try {
			xpp.setInput(source, encoding);

			if (DEBUG)
				log("Underlying XmlPullParser input set [type=InputStream, encoding=%s (null is OK)]",
						xpp.getInputEncoding());
		} catch (XmlPullParserException e) {
			throw new XMLParserException(
					"Unable to set the given InputStream (with an optional encoding of '"
							+ encoding
							+ "') as input for the underlying XmlPullParser.",
					e);
		}

		try {
			doParse();
		} catch (IOException e) {
			throw new XMLParserException(
					"An exception occurred while parsing the given source, the XML document may be malformed.",
					e);
		} catch (XmlPullParserException e) {
			throw new XMLParserException(
					"An error with the underlying data stream being parsed occurred.",
					e);
		}
	}

	protected void doParse() throws IOException, XmlPullParserException {
		location.clear();
		boolean continueParsing = true;

		if (DEBUG)
			log("Parsing starting...");

		long startTime = System.currentTimeMillis();

		while (continueParsing) {
			switch (xpp.next()) {
			case XmlPullParser.START_TAG:
				doStartTag();
				break;

			case XmlPullParser.TEXT:
				doText();
				break;

			case XmlPullParser.END_TAG:
				doEndTag();
				break;

			case XmlPullParser.END_DOCUMENT:
				continueParsing = false;

				if (DEBUG)
					log("END_DOCUMENT, Parsing COMPLETE");
				break;
			}
		}

		if (DEBUG) {
			long duration = System.currentTimeMillis() - startTime;
			log("Parse COMPLETE, elapsed time: %dms (approx %f seconds)",
					duration, (double) duration / (double) 1000);
		}
	}

	protected void doStartTag() {
		// Update parser location
		location.push(xpp.getName(), xpp.getNamespace());

		if (DEBUG)
			log("START_TAG: %s", location);

		// Get the rules for the current path
		List<IRule> ruleList = attrRuleMap.get(location.toString());

		// If there are no rules for the current path, then we are done.
		if (ruleList == null || ruleList.isEmpty())
			return;

		if (DEBUG)
			log("\t%d rules found for START_TAG...", ruleList.size());

		for (IRule rule : ruleList) {
			if (DEBUG)
				log("\t\tRunning Rule: %s", rule);

			String[] attrs = rule.getAttributeNames();

			// Jump to the next rule if this one has no attribute entries
			if (attrs == null || attrs.length == 0)
				continue;

			for (int i = 0; i < attrs.length; i++) {
				String attr = attrs[i];
				String localName = null;
				String namespaceURI = null;

				// Parse the namespaceURI out of the attr if necessary
				if (attr.charAt(0) == '[') {
					int endIndex = attr.indexOf(']');

					/*
					 * Make sure the rule is valid so we avoid out of bounds and
					 * keep the caller informed when their rules are busted by
					 * failing fast.
					 */
					if (endIndex <= 2)
						throw new XMLParserException(
								"namespace URI for rule looks to be incomplete or empty for IRule: "
										+ rule);

					namespaceURI = attr.substring(1, endIndex);
				}

				int startIndex = (namespaceURI == null ? 0 : namespaceURI
						.length() + 2);

				/*
				 * Make sure the rule is valid so we avoid out of bounds and
				 * keep the caller informed when their rules are busted by
				 * failing fast.
				 */
				if (attr.length() - startIndex <= 1)
					throw new XMLParserException(
							"local name for rule looks to be missing for IRule: "
									+ rule);

				// Parse the local name
				localName = attr.substring(startIndex, attr.length());

				// Give the parsed attribute value to the matching rule
				rule.handleParsedAttribute(i,
						xpp.getAttributeValue(namespaceURI, localName));
			}
		}
	}

	protected void doText() {
		if (DEBUG)
			log("TEXT: %s", location);

		// Get the rules for the current path
		List<IRule> ruleList = charRuleMap.get(location.toString());

		// If there are no rules for the current path, then we are done.
		if (ruleList == null || ruleList.isEmpty())
			return;

		if (DEBUG)
			log("\t%d rules found for TEXT...", ruleList.size());

		String text = xpp.getText();

		// Give the parsed text to all matching IRules for this path
		for (IRule rule : ruleList) {
			if (DEBUG)
				log("\t\tRunning Rule: %s", rule);

			rule.handleParsedCharacters(text);
		}
	}

	protected void doEndTag() {
		// Update parser location
		location.pop();

		if (DEBUG)
			log("END_TAG: %s", location);
	}

	class Location {
		private StringBuilder path;
		private List<Integer> lengthList;

		public Location() {
			path = new StringBuilder(256);
			lengthList = new ArrayList<Integer>(16);
		}

		@Override
		public String toString() {
			return path.toString();
		}

		public void clear() {
			path.setLength(0);
			lengthList.clear();
		}

		public void push(String localName, String namespaceURI) {
			// Remember the length before we inserted this last entry
			lengthList.add(path.length());

			// Add separator
			path.append('/');

			// Add the namespace URI if there is one.
			if (namespaceURI != null && namespaceURI.length() > 0)
				path.append('[').append(namespaceURI).append(']');

			// Append the local name
			path.append(localName);
		}

		public void pop() {
			// Get the length before the last insertion
			Integer lastLength = lengthList.remove(lengthList.size() - 1);

			// 'Pop' the last insertion by cropping the length to exclude it.
			path.setLength(lastLength);
		}
	}
}